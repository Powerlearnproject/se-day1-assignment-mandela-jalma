[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18500616&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is a branch of both computer science and engineering that refers to the process of designing, building, testing and maintaining software applications.
Importance of software engineering to the technological industry.

Handling Big Projects: Software engineering methodology is used in handling of large projects without any issues.
To manage the cost: Software engineering helps its programmers to plan everything and reduce all those things that are not required.
To decrease time: It will save a lot of time if one is developing a software using a software engineering technique.
Reliable software: Software engineering enables the creation of reliable software products on schedule and to address any defects that may exist.
Effectiveness: Effectiveness results from things being created in accordance with the standards.
Reduces complexity: Large challenges are broken down into smaller ones and solved one at a time in software engineering. Individual solutions are found for each of these issues.
Productivity: Because it contains testing systems at every level, proper care is done to maintain software productivity.

Identify and describe at least three key milestones in the evolution of software engineering.
A milestone is a specific point in time within a project lifecycle used to measure the progress of a project toward its ultimate goal.

SE Era I: Mastering the Machine (1956–1967)
The term software engineering had not yet been coined. Code development was strongly influenced by outside forces. The main purpose of any piece of software was to optimize exploitation of the limited hardware resources. The first compilers were defined; operating systems were noninteractive. These primitive environments continued evolving up to the definition of the first low-level Computer Aided Software Engineering tools (CASE tools) facilitating interactive editing, compiling, and debugging. The lack of software development methods led to high risk and the origin of a new stage is easily noticeable.

SE Era II: Mastering the Process (1968–1982)
The first software crisis in this stage led to the birth of software engineering. The aim was to reduce risk during development and improve quality and productivity. Software development methodologies appeared to define and monitor software building. An important contribution of this stage was the formal modeling approach that enables implementation automation. But for industry, this formal approach was unfeasible due to a lack of tools and training. Furthermore, formal methods become unmanageable for large system development. In conclusion, in this stage, the need to focus on predesign phases and the use of more or less formal models for software specification began to appear. A number of structured methods, such as Software Requirement Engineering Methodology (SREM) and the Structured Analysis and Design Technique (SADT). were developed allowing the development of specification documents for business management software.

SE Era III: Mastering the Complexity (1983–1992)
The up to then dominion of hardware over software ended. Personal computers arrived and opened the fields of computer applications. The software development process would now comprehensively address analysis and design from the specification. Graphical user interface and visual programming brought software closer to customers. The use of structured family and data modeling methodologies was extended. Several CASE tools facilitated software development. However, data modeling (database) and function modeling (structured methods) still followed separate paths. These two modeling paths converged in object-oriented (OO) methods like early on in structured methodologies, they were first introduced in coding and design, and finally in specification and analysis. This approach enables efficient reuse of object-oriented software and thus improves building software productivity.

List and briefly explain the phases of the Software Development Life Cycle.
Planning.
The initial stage of software development, Planning, involves defining the software's purpose and scope, much like pinpointing our destination and plotting the best route. We uncover the tasks at hand during this phase and strategize for efficient execution.

Requirement analysis
Phase 2 of the SDLC, Requirements Analysis, seeks to identify and record the precise requirements of the final users. In this phase, the team is looking to answer, "What are the expectations of our users from our software?" This is called requirements gathering.
The project team collects information from stakeholders, including analysts, users, and clients. They conduct interviews, surveys, and focus groups to understand the user's expectations and needs. The process involves not only asking the right questions but also accurately interpreting the responses.

Design
The Design phase is all about building the framework. The development team is responsible for software engineering and outlines the software's functionality and aesthetic. This ultimately results in the software product. The emphasis lies on outlining the software's structure, navigation, user interfaces, and database design. This phase ensures that the software is user-friendly and performs its tasks efficiently.

Coding.
The Coding phase in the Software Development Life Cycle (SDLC) is when engineers and developers get down to business and start converting the software design into tangible code.This development phase aims to develop software that is functional, efficient, and user-friendly. Developers use an appropriate programming language, Java or otherwise, to write the code, guided by the SDD and coding guidelines. This document, acting as a roadmap, ensures the software aligns with the vision set in earlier phases.

Testing.
 The testing phase of the SDLC  should be considered as a stringent quality inspection on a production line. It is when vulnerabilities are uncovered. Software testing involves a thorough examination of the software for any bugs or glitches that might have slipped through during coding. The aim is to ensure flawless software operation before it reaches the end-users. And even identify opportunities for enhancement.

 Deployment.
 After crafting a product with precision, it's time to present it to the users by pushing to the production environment. The Deployment phase involves rolling out the meticulously tested and fine-tuned software to its end-users.

 Maintenance.
 In the Software Development Life Cycle, the maintenance phase is characterized by constant assistance and improvement, which guarantees the software's best possible functioning and longevity and ensures it meets customer expectations. The primary focus is to adapt to the software's changing needs. This adaptation involves responding to user feedback, resolving unexpected issues, and upgrading the software based on users' evolving requirements. It's a continuous process of refining and adapting.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
Waterfall Model
This is a linear and sequential approach where each phase must be completed prior to moving on to the next step. The phases include requirements, design, implementation, testing, deployment, and maintenance. Waterfall suits projects that require a high volume of documentation and have repeatable, predictable processes. It is especially effective for projects with well-defined requirements and minimal expected changes, ensuring consistency and traceable control.

Agile Model
The agile methodology is an iterative and incremental approach that emphasizes flexibility and collaboration between cross-functional teams. When implementing an agile model, requirements and solutions evolve through collaboration and adaptation to change. Agile is best for projects that have flexible processes and incorporate customer feedback throughout the process.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Project Manager 
In software development, the roles of the project manager may include helping the team to design, execute, monitor and finish their work so that the clients will receive higher-quality software products. 

Responsibilities 
Discuss the project and its requirements with clients and software developers.
Assemble and lead the software development team.
Create the blueprint for the project, including the scope, allocating resources, setting deadlines and laying out communication strategies.
Supervising each stage of the software development project.
Set the budget and ensure the project adheres to it as closely as possible.
Tracking and communicating information regarding the project milestones, deliverables and change requests.
Deliver the completed software to the client and regularly check its performance. 

QA Engineer 
The quality assurance engineers  create tests that identify issues with software before it is deployed. 

Quality assurance engineers monitor every phase of the software development process, including development, testing, debugging and delivery. They ensure that quality is maintained at every stage of the development process and that the final product meets the requirements.

Responsibilities 
Collaborate with stakeholders to understand and clarify software requirements.
Create development standards and procedures for the programmers to follow. 
Confirm that the software meets the requirements before deployment.
Analyse the product to identify bugs and suggest changes to make them more efficient. 
Develop and execute automation scripts using open-source tools.

Software Developer
The developer is responsible for writing the code and developing the entire software product. Aside from coding, a software developer is responsible for sending updates to the project manager and working closely with other team members, including the designer and QA engineer. 

The kind of software developer you hire for your team depends on your desired software. If you want a mobile application, you need an iOS or an Android developer. However, if you want to develop a web application, you need a front-end, back-end or full-stack developer. 
Responsibilities 
Developing applications, programs and systems using programming languages and frameworks.
Maintaining and updating software to keep it functional.
Collaborating with other team members to ensure best practices when developing software.
Report to the project manager about the progress of the software development.  

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
Integrated Development Environments (IDEs) and Version Control Systems (VCS) are crucial tools for software developers.

Integrated Development Environments (IDEs)
IDEs provide a comprehensive environment for software development, offering features such as code editing, debugging, and build automation in a single application. They enhance productivity by providing tools for code completion, syntax highlighting, and project management. IDEs also facilitate collaboration through features like integrated version control and team communication tools. Examples of IDEs include NetBeans, Eclipse, IntelliJ, and Visual Studio.

Version Control Systems (VCS)
VCS are essential for tracking changes in code, enabling collaboration, and ensuring the integrity of the codebase. They allow developers to work on the same codebase simultaneously, manage different versions of the code, and revert to previous versions if needed. VCS also provide features for branching, merging, and conflict resolution, which are crucial for team-based development. Examples of version control tools include Git, Subversion, Mercurial, Bitbucket, and AWS CodeCommit.

Importance in Software Development
Efficiency: IDEs streamline the development process, offering tools for coding, testing, and debugging within a unified interface. This reduces the time and effort required for development tasks.
Collaboration: VCS enables multiple developers to work on the same codebase concurrently, facilitating collaboration and reducing the risk of code conflicts.
Code Integrity: VCS tracks changes to the codebase, providing a history of modifications and enabling developers to revert to previous versions if necessary.
Quality Assurance: IDEs often include built-in testing and debugging tools, which contribute to the overall quality of the software by identifying and resolving issues early in the development process.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

Managing Complexity
Challenge: Large software systems can become difficult to manage due to their complexity.
Strategy: Break the system into smaller, modular components, use design patterns, and maintain clear documentation to manage complexity effectively.
Meeting Tight Deadlines
Challenge: Software engineers often work under pressure to deliver projects quickly, which can impact quality.
Strategy: Use Agile methodologies, prioritize essential features, and set realistic deadlines to ensure quality while meeting deadlines.
Handling Bugs and Debugging
Challenge: Debugging can be time-consuming and challenging, especially in large systems.
Strategy: Implement automated testing, use version control, and leverage debugging tools to identify and resolve bugs efficiently.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Types of Testing and Their Importance

Unit Testing
Unit testing involves testing individual components or units of a software application in isolation.
It ensures that each unit functions as expected and helps identify and fix bugs early in the development process.
By verifying the correctness of individual units, it contributes to the overall reliability and stability of the software.

Integration Testing
Integration testing focuses on testing the interactions and interfaces between integrated components or modules.
It ensures that the integrated units work together as intended and helps detect issues related to data flow, communication, and dependencies.
It is crucial for identifying and resolving integration-related defects, thereby improving the overall performance and functionality of the software.

System Testing
System testing involves testing the entire software application as a complete and integrated system.
It verifies that the system meets the specified requirements and functions correctly in the intended environment.
By testing the system as a whole, it helps ensure that all components work together seamlessly and that the software meets quality and performance standards.

Acceptance Testing
Acceptance testing is performed to validate whether the software meets the business requirements and is ready for deployment.
It involves testing the software with real-world scenarios and user interactions to ensure that it meets the users' needs and expectations.
By gaining user acceptance and feedback, it helps ensure that the software is fit for purpose and meets the desired business objectives.
In conclusion, each type of testing plays a crucial role in software quality assurance by addressing different aspects of the software development process. Unit testing ensures the correctness of individual units, integration testing verifies the interactions between components, system testing validates the entire system, and acceptance testing ensures that the software meets user expectations and business requirements. Together, these testing types contribute to the overall quality, reliability, and functionality of the software.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the process where you guide generative artificial intelligence (generative AI) solutions to generate desired outputs.Prompt engineering is important in AI because it helps ensure that AI models produce accurate and relevant responses.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
Write an essay on hemoflagellates.
Improved prompt.
Write an essay on hemoflagellates in 1000 words espescially Leishmania leaving no detail out.
The improved prompt is more effective because it provides clear and specific guidelines for the essay. It specifies the word count, the topic and the context 











